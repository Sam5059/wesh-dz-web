import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  TextInput,
  Platform,
  ActivityIndicator,
} from 'react-native';
import { ChevronDown, ChevronUp, X } from 'lucide-react-native';
import { supabase } from '@/lib/supabase';
import { useLanguage } from '@/contexts/LanguageContext';

interface FiltersSidebarProps {
  selectedCategory?: string;
  onFiltersChange: (filters: any) => void;
  totalResults: number;
  onReset: () => void;
  currentSearchQuery?: string;
  currentFilters?: any;
}

interface FilterSection {
  id: string;
  label: string;
  type: 'checkbox' | 'range' | 'select' | 'radio';
  options?: Array<{ value: string; label: string; count?: number }>;
  min?: number;
  max?: number;
}

export default function FiltersSidebar({
  selectedCategory,
  onFiltersChange,
  totalResults,
  onReset,
  currentSearchQuery,
  currentFilters,
}: FiltersSidebarProps) {
  const { language } = useLanguage();
  const [expandedSections, setExpandedSections] = useState<Set<string>>(new Set(['categories', 'price']));
  const [filters, setFilters] = useState<any>(selectedCategory ? { category_id: selectedCategory } : {});
  const [categories, setCategories] = useState<any[]>([]);
  const [categoryCounts, setCategoryCounts] = useState<Record<string, number>>({});
  const [brands, setBrands] = useState<any[]>([]);
  const [wilayas, setWilayas] = useState<any[]>([]);
  const [dynamicFilters, setDynamicFilters] = useState<FilterSection[]>([]);
  const [loadingCategories, setLoadingCategories] = useState(false);
  const [loadingWilayas, setLoadingWilayas] = useState(false);
  const [loadingDynamic, setLoadingDynamic] = useState(false);
  const onFiltersChangeRef = useRef(onFiltersChange);

  const isRTL = language === 'ar';

  useEffect(() => {
    onFiltersChangeRef.current = onFiltersChange;
  }, [onFiltersChange]);

  useEffect(() => {
    console.log('FiltersSidebar mounted - loading initial data');
    loadCategories();
    loadWilayas();
  }, []);

  useEffect(() => {
    if (selectedCategory && filters.category_id !== selectedCategory) {
      setFilters(prev => ({ ...prev, category_id: selectedCategory }));
    }
    loadDynamicFilters();
  }, [selectedCategory]);

  useEffect(() => {
    if (categories.length > 0) {
      // Debounce pour éviter trop de requêtes
      const timer = setTimeout(() => {
        loadCategoryCounts(categories);
      }, 300);

      return () => clearTimeout(timer);
    }
  }, [categories, currentSearchQuery, currentFilters?.price_min, currentFilters?.price_max, currentFilters?.wilaya, selectedCategory]);

  useEffect(() => {
    onFiltersChangeRef.current(filters);
  }, [filters]);

  async function loadCategories() {
    setLoadingCategories(true);
    try {
      const { data: cats } = await supabase
        .from('categories')
        .select('id, name, name_ar, name_en, slug, display_order')
        .is('parent_id', null)
        .order('display_order', { ascending: true, nullsFirst: false });

      if (cats) {
        // Exclure "stores-pro" des catégories de filtres
        const filteredCats = cats.filter(cat => cat.slug !== 'stores-pro');
        setCategories(filteredCats);
        await loadCategoryCounts(filteredCats);
      }
    } finally {
      setLoadingCategories(false);
    }
  }

  async function loadCategoryCounts(cats: any[]) {
    const counts: Record<string, number> = {};

    // Charger tous les compteurs en UNE SEULE requête optimisée
    try {
      // 1. Charger toutes les sous-catégories en une fois
      const { data: allSubcats } = await supabase
        .from('categories')
        .select('id, parent_id')
        .in('parent_id', cats.map(c => c.id));

      // 2. Créer un mapping parent -> sous-catégories
      const parentToSubcats: Record<string, string[]> = {};
      cats.forEach(cat => {
        parentToSubcats[cat.id] = [];
      });

      allSubcats?.forEach(subcat => {
        if (subcat.parent_id && parentToSubcats[subcat.parent_id]) {
          parentToSubcats[subcat.parent_id].push(subcat.id);
        }
      });

      // Ajouter les catégories parentes elles-mêmes si pas de sous-catégories
      cats.forEach(cat => {
        if (parentToSubcats[cat.id].length === 0) {
          parentToSubcats[cat.id].push(cat.id);
        }
      });

      // 3. Charger TOUS les listings actifs en une seule requête
      let query = supabase
        .from('listings')
        .select('id, category_id')
        .eq('status', 'active');

      // Appliquer seulement les filtres essentiels (pas de recherche textuelle)
      if (currentFilters?.price_min) {
        query = query.gte('price', currentFilters.price_min);
      }
      if (currentFilters?.price_max) {
        query = query.lte('price', currentFilters.price_max);
      }
      if (currentFilters?.wilaya) {
        query = query.eq('wilaya', currentFilters.wilaya);
      }

      const { data: listings } = await query;

      // 4. Compter côté client (très rapide)
      cats.forEach(cat => {
        const subcatIds = parentToSubcats[cat.id];
        counts[cat.id] = listings?.filter(l => subcatIds.includes(l.category_id)).length || 0;
      });

    } catch (error) {
      console.error('Error loading category counts:', error);
      // En cas d'erreur, mettre tous les compteurs à 0
      cats.forEach(cat => {
        counts[cat.id] = 0;
      });
    }

    setCategoryCounts(counts);
  }

  async function loadWilayas() {
    setLoadingWilayas(true);
    try {
      const { data } = await supabase
        .from('wilayas')
        .select('code, name, name_ar, name_en')
        .order('code');

      if (data) setWilayas(data);
    } finally {
      setLoadingWilayas(false);
    }
  }

  async function loadDynamicFilters() {
    if (!selectedCategory) {
      setDynamicFilters([]);
      return;
    }

    setLoadingDynamic(true);
    try {

    const { data: categoryData } = await supabase
      .from('categories')
      .select('slug')
      .eq('id', selectedCategory)
      .single();

    if (!categoryData) return;

    const slug = categoryData.slug;
    const filters: FilterSection[] = [];

    if (slug === 'voitures' || slug === 'motos' || slug === 'camions') {
      const { data: brandsList } = await supabase
        .from('brands')
        .select('id, name')
        .eq('category_type', 'vehicules')
        .order('name');

      filters.push({
        id: 'brand',
        label: language === 'ar' ? 'الماركة' : language === 'en' ? 'Brand' : 'Marque',
        type: 'select',
        options: brandsList?.map(b => ({ value: b.id, label: b.name })) || [],
      });

      filters.push({
        id: 'year',
        label: language === 'ar' ? 'السنة' : language === 'en' ? 'Year' : 'Année',
        type: 'range',
        min: 1990,
        max: new Date().getFullYear(),
      });

      filters.push({
        id: 'mileage',
        label: language === 'ar' ? 'الكيلومتراج' : language === 'en' ? 'Mileage' : 'Kilométrage',
        type: 'range',
        min: 0,
        max: 500000,
      });

      filters.push({
        id: 'transmission',
        label: language === 'ar' ? 'ناقل الحركة' : language === 'en' ? 'Transmission' : 'Transmission',
        type: 'radio',
        options: [
          { value: 'manuelle', label: language === 'ar' ? 'يدوي' : language === 'en' ? 'Manual' : 'Manuelle' },
          { value: 'automatique', label: language === 'ar' ? 'أوتوماتيكي' : language === 'en' ? 'Automatic' : 'Automatique' },
        ],
      });

      filters.push({
        id: 'fuel',
        label: language === 'ar' ? 'الوقود' : language === 'en' ? 'Fuel' : 'Carburant',
        type: 'radio',
        options: [
          { value: 'essence', label: language === 'ar' ? 'بنزين' : language === 'en' ? 'Gasoline' : 'Essence' },
          { value: 'diesel', label: language === 'ar' ? 'ديزل' : 'Diesel' },
          { value: 'electrique', label: language === 'ar' ? 'كهربائي' : language === 'en' ? 'Electric' : 'Électrique' },
          { value: 'hybride', label: language === 'ar' ? 'هجين' : language === 'en' ? 'Hybrid' : 'Hybride' },
        ],
      });
    } else if (slug === 'appartements' || slug === 'maisons-villas' || slug === 'terrains') {
      filters.push({
        id: 'surface',
        label: language === 'ar' ? 'المساحة (م²)' : language === 'en' ? 'Surface (m²)' : 'Surface (m²)',
        type: 'range',
        min: 0,
        max: 1000,
      });

      filters.push({
        id: 'rooms',
        label: language === 'ar' ? 'عدد الغرف' : language === 'en' ? 'Rooms' : 'Pièces',
        type: 'checkbox',
        options: [
          { value: '1', label: '1' },
          { value: '2', label: '2' },
          { value: '3', label: '3' },
          { value: '4', label: '4' },
          { value: '5+', label: '5+' },
        ],
      });
    } else if (slug.includes('telephone') || slug.includes('ordinateur') || slug.includes('tablette')) {
      const { data: brandsList } = await supabase
        .from('brands')
        .select('id, name')
        .eq('category_type', 'electronique')
        .order('name');

      filters.push({
        id: 'brand',
        label: language === 'ar' ? 'الماركة' : language === 'en' ? 'Brand' : 'Marque',
        type: 'select',
        options: brandsList?.map(b => ({ value: b.id, label: b.name })) || [],
      });

      filters.push({
        id: 'storage',
        label: language === 'ar' ? 'التخزين' : language === 'en' ? 'Storage' : 'Stockage',
        type: 'checkbox',
        options: [
          { value: '32GB', label: '32 GB' },
          { value: '64GB', label: '64 GB' },
          { value: '128GB', label: '128 GB' },
          { value: '256GB', label: '256 GB' },
          { value: '512GB', label: '512 GB' },
          { value: '1TB', label: '1 TB' },
        ],
      });
    }

    setDynamicFilters(filters);
    } finally {
      setLoadingDynamic(false);
    }
  }

  const toggleSection = (sectionId: string) => {
    setExpandedSections(prev => {
      const newSet = new Set(prev);
      if (newSet.has(sectionId)) {
        newSet.delete(sectionId);
      } else {
        newSet.add(sectionId);
      }
      return newSet;
    });
  };

  const updateFilter = (key: string, value: any) => {
    setFilters((prev: any) => {
      if (value === null || value === undefined || value === '') {
        const newFilters = { ...prev };
        delete newFilters[key];
        return newFilters;
      }
      return { ...prev, [key]: value };
    });
  };

  const getCategoryName = (cat: any) => {
    if (language === 'ar') return cat.name_ar || cat.name;
    if (language === 'en') return cat.name_en || cat.name;
    return cat.name;
  };

  const getWilayaName = (wilaya: any) => {
    if (language === 'ar') return wilaya.name_ar || wilaya.name;
    if (language === 'en') return wilaya.name_en || wilaya.name;
    return wilaya.name;
  };

  const handleReset = () => {
    setFilters({});
    onReset();
  };

  const renderCheckboxFilter = (filter: FilterSection) => {
    const selectedValues = filters[filter.id] || [];

    return (
      <View style={styles.filterOptions}>
        {filter.options?.map((option) => (
          <TouchableOpacity
            key={option.value}
            style={styles.checkboxOption}
            onPress={() => {
              const newValues = selectedValues.includes(option.value)
                ? selectedValues.filter((v: string) => v !== option.value)
                : [...selectedValues, option.value];
              updateFilter(filter.id, newValues.length > 0 ? newValues : null);
            }}
          >
            <View style={[
              styles.checkbox,
              selectedValues.includes(option.value) && styles.checkboxChecked
            ]}>
              {selectedValues.includes(option.value) && (
                <Text style={styles.checkmark}>✓</Text>
              )}
            </View>
            <Text style={[styles.checkboxLabel, isRTL && styles.textRTL]}>
              {option.label}
              {option.count !== undefined && ` (${option.count})`}
            </Text>
          </TouchableOpacity>
        ))}
      </View>
    );
  };

  const renderRadioFilter = (filter: FilterSection) => {
    const selectedValue = filters[filter.id];

    return (
      <View style={styles.filterOptions}>
        {filter.options?.map((option) => (
          <TouchableOpacity
            key={option.value}
            style={styles.radioOption}
            onPress={() => {
              updateFilter(filter.id, selectedValue === option.value ? null : option.value);
            }}
          >
            <View style={[
              styles.radio,
              selectedValue === option.value && styles.radioSelected
            ]}>
              {selectedValue === option.value && (
                <View style={styles.radioDot} />
              )}
            </View>
            <Text style={[styles.radioLabel, isRTL && styles.textRTL]}>
              {option.label}
            </Text>
          </TouchableOpacity>
        ))}
      </View>
    );
  };

  const renderRangeFilter = (filter: FilterSection) => {
    const minValue = filters[`${filter.id}_min`] || '';
    const maxValue = filters[`${filter.id}_max`] || '';

    return (
      <View style={styles.rangeContainer}>
        <View style={styles.rangeInputs}>
          <TextInput
            style={[styles.rangeInput, isRTL && styles.textRTL]}
            placeholder={language === 'ar' ? 'الأدنى' : language === 'en' ? 'Min' : 'Min'}
            value={minValue.toString()}
            onChangeText={(text) => updateFilter(`${filter.id}_min`, text ? parseInt(text) : null)}
            keyboardType="numeric"
          />
          <Text style={styles.rangeSeparator}>-</Text>
          <TextInput
            style={[styles.rangeInput, isRTL && styles.textRTL]}
            placeholder={language === 'ar' ? 'الأقصى' : language === 'en' ? 'Max' : 'Max'}
            value={maxValue.toString()}
            onChangeText={(text) => updateFilter(`${filter.id}_max`, text ? parseInt(text) : null)}
            keyboardType="numeric"
          />
        </View>
      </View>
    );
  };

  const renderSelectFilter = (filter: FilterSection) => {
    const selectedValue = filters[filter.id];

    return (
      <ScrollView style={styles.selectContainer} nestedScrollEnabled>
        {filter.options?.map((option) => (
          <TouchableOpacity
            key={option.value}
            style={[
              styles.selectOption,
              selectedValue === option.value && styles.selectOptionSelected
            ]}
            onPress={() => {
              updateFilter(filter.id, selectedValue === option.value ? null : option.value);
            }}
          >
            <Text style={[
              styles.selectOptionText,
              selectedValue === option.value && styles.selectOptionTextSelected,
              isRTL && styles.textRTL
            ]}>
              {option.label}
            </Text>
          </TouchableOpacity>
        ))}
      </ScrollView>
    );
  };


  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <Text style={[styles.resultsCount, isRTL && styles.textRTL]}>
          {totalResults} {language === 'ar' ? 'إعلان' : language === 'en' ? 'listings' : 'annonces'}
        </Text>
        <TouchableOpacity onPress={handleReset}>
          <Text style={styles.resetButton}>
            {language === 'ar' ? 'إعادة تعيين' : language === 'en' ? 'Reset' : 'Réinitialiser'}
          </Text>
        </TouchableOpacity>
      </View>

      <ScrollView style={styles.scrollView} showsVerticalScrollIndicator={false}>
        {/* Categories */}
        <View style={styles.filterSection}>
          <TouchableOpacity
            style={styles.filterHeader}
            onPress={() => toggleSection('categories')}
          >
            <Text style={[styles.filterTitle, isRTL && styles.textRTL]}>
              {language === 'ar' ? 'الفئات' : language === 'en' ? 'Categories' : 'CATÉGORIES'}
            </Text>
            {expandedSections.has('categories') ? (
              <ChevronUp size={18} color="#64748B" />
            ) : (
              <ChevronDown size={18} color="#64748B" />
            )}
          </TouchableOpacity>

          {expandedSections.has('categories') && (
            <View style={styles.filterContent}>
              {loadingCategories ? (
                <ActivityIndicator size="small" color="#2563EB" style={{ padding: 20 }} />
              ) : categories.length === 0 ? (
                <Text style={[styles.emptyText, isRTL && styles.textRTL]}>
                  {language === 'ar' ? 'لا توجد فئات' : language === 'en' ? 'No categories' : 'Aucune catégorie'}
                </Text>
              ) : (
                categories.map((cat) => (
                  <TouchableOpacity
                    key={cat.id}
                    style={[
                      styles.categoryItem,
                      filters.category_id === cat.id && styles.categoryItemActive
                    ]}
                    onPress={() => {
                      // Permettre de désélectionner la catégorie en cliquant à nouveau
                      const newCategoryId = filters.category_id === cat.id ? null : cat.id;
                      updateFilter('category_id', newCategoryId);
                    }}
                  >
                    <Text style={[
                      styles.categoryText,
                      filters.category_id === cat.id && styles.categoryTextActive,
                      isRTL && styles.textRTL
                    ]}>
                      {getCategoryName(cat)}
                    </Text>
                    <Text style={[
                      styles.categoryCount,
                      filters.category_id === cat.id && styles.categoryCountActive
                    ]}>
                      ({categoryCounts[cat.id] || 0})
                    </Text>
                  </TouchableOpacity>
                ))
              )}
            </View>
          )}
        </View>

        {/* Localisation */}
        <View style={styles.filterSection}>
          <TouchableOpacity
            style={styles.filterHeader}
            onPress={() => toggleSection('location')}
          >
            <Text style={[styles.filterTitle, isRTL && styles.textRTL]}>
              {language === 'ar' ? 'الموقع' : language === 'en' ? 'Location' : 'Localisation'}
            </Text>
            {expandedSections.has('location') ? (
              <ChevronUp size={18} color="#64748B" />
            ) : (
              <ChevronDown size={18} color="#64748B" />
            )}
          </TouchableOpacity>

          {expandedSections.has('location') && (
            <View style={styles.filterContent}>
              <ScrollView style={styles.wilayasList} nestedScrollEnabled>
                {wilayas.map((wilaya) => (
                  <TouchableOpacity
                    key={wilaya.code}
                    style={[
                      styles.wilayaItem,
                      filters.wilaya === wilaya.code && styles.wilayaItemSelected
                    ]}
                    onPress={() => {
                      updateFilter('wilaya', filters.wilaya === wilaya.code ? null : wilaya.code);
                    }}
                  >
                    <Text style={[
                      styles.wilayaText,
                      filters.wilaya === wilaya.code && styles.wilayaTextSelected,
                      isRTL && styles.textRTL
                    ]}>
                      {getWilayaName(wilaya)}
                    </Text>
                  </TouchableOpacity>
                ))}
              </ScrollView>
            </View>
          )}
        </View>

        {/* Prix */}
        <View style={styles.filterSection}>
          <TouchableOpacity
            style={styles.filterHeader}
            onPress={() => toggleSection('price')}
          >
            <Text style={[styles.filterTitle, isRTL && styles.textRTL]}>
              {language === 'ar' ? 'السعر' : language === 'en' ? 'Price' : 'Prix'}
            </Text>
            {expandedSections.has('price') ? (
              <ChevronUp size={18} color="#64748B" />
            ) : (
              <ChevronDown size={18} color="#64748B" />
            )}
          </TouchableOpacity>

          {expandedSections.has('price') && (
            <View style={styles.filterContent}>
              <View style={styles.rangeContainer}>
                <TextInput
                  style={[styles.rangeInput, isRTL && styles.textRTL]}
                  placeholder={language === 'ar' ? 'الأدنى' : 'Min'}
                  value={filters.price_min?.toString() || ''}
                  onChangeText={(text) => updateFilter('price_min', text ? parseInt(text) : null)}
                  keyboardType="numeric"
                  placeholderTextColor="#94A3B8"
                />
                <TextInput
                  style={[styles.rangeInput, isRTL && styles.textRTL]}
                  placeholder={language === 'ar' ? 'الأقصى' : 'Max'}
                  value={filters.price_max?.toString() || ''}
                  onChangeText={(text) => updateFilter('price_max', text ? parseInt(text) : null)}
                  keyboardType="numeric"
                  placeholderTextColor="#94A3B8"
                />
              </View>
            </View>
          )}
        </View>

        {/* Dynamic Filters based on category */}
        {dynamicFilters.map((filter) => (
          <View key={filter.id} style={styles.filterSection}>
            <TouchableOpacity
              style={styles.filterHeader}
              onPress={() => toggleSection(filter.id)}
            >
              <Text style={[styles.filterTitle, isRTL && styles.textRTL]}>
                {filter.label}
              </Text>
              {expandedSections.has(filter.id) ? (
                <ChevronUp size={18} color="#64748B" />
              ) : (
                <ChevronDown size={18} color="#64748B" />
              )}
            </TouchableOpacity>

            {expandedSections.has(filter.id) && (
              <View style={styles.filterContent}>
                {filter.type === 'checkbox' && renderCheckboxFilter(filter)}
                {filter.type === 'radio' && renderRadioFilter(filter)}
                {filter.type === 'range' && renderRangeFilter(filter)}
                {filter.type === 'select' && renderSelectFilter(filter)}
              </View>
            )}
          </View>
        ))}

        {/* Condition */}
        <View style={styles.filterSection}>
          <TouchableOpacity
            style={styles.filterHeader}
            onPress={() => toggleSection('condition')}
          >
            <Text style={[styles.filterTitle, isRTL && styles.textRTL]}>
              {language === 'ar' ? 'الحالة' : language === 'en' ? 'Condition' : 'État'}
            </Text>
            {expandedSections.has('condition') ? (
              <ChevronUp size={18} color="#64748B" />
            ) : (
              <ChevronDown size={18} color="#64748B" />
            )}
          </TouchableOpacity>

          {expandedSections.has('condition') && (
            <View style={styles.filterContent}>
              {['new', 'like_new', 'good', 'fair'].map((cond) => (
                <TouchableOpacity
                  key={cond}
                  style={styles.radioOption}
                  onPress={() => {
                    updateFilter('condition', filters.condition === cond ? null : cond);
                  }}
                >
                  <View style={[
                    styles.radio,
                    filters.condition === cond && styles.radioSelected
                  ]}>
                    {filters.condition === cond && (
                      <View style={styles.radioDot} />
                    )}
                  </View>
                  <Text style={[styles.radioLabel, isRTL && styles.textRTL]}>
                    {cond === 'new' && (language === 'ar' ? 'جديد' : language === 'en' ? 'New' : 'Neuf')}
                    {cond === 'like_new' && (language === 'ar' ? 'كالجديد' : language === 'en' ? 'Like New' : 'Comme neuf')}
                    {cond === 'good' && (language === 'ar' ? 'جيد' : language === 'en' ? 'Good' : 'Bon état')}
                    {cond === 'fair' && (language === 'ar' ? 'مقبول' : language === 'en' ? 'Fair' : 'Acceptable')}
                  </Text>
                </TouchableOpacity>
              ))}
            </View>
          )}
        </View>
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    width: 320,
    backgroundColor: '#FFFFFF',
    borderRightWidth: 1,
    borderRightColor: '#E2E8F0',
    height: '100%',
    overflow: 'hidden',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#E2E8F0',
  },
  resultsCount: {
    fontSize: 16,
    fontWeight: '600',
    color: '#0F172A',
  },
  resetButton: {
    fontSize: 14,
    color: '#2563EB',
    fontWeight: '600',
  },
  scrollView: {
    flex: 1,
  },
  filterSection: {
    borderBottomWidth: 1,
    borderBottomColor: '#E2E8F0',
  },
  filterHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    backgroundColor: '#F8FAFC',
  },
  filterTitle: {
    fontSize: 13,
    fontWeight: '700',
    color: '#475569',
    textTransform: 'uppercase',
    letterSpacing: 0.5,
  },
  filterContent: {
    padding: 12,
  },
  filterOptions: {
    gap: 12,
  },
  checkboxOption: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 10,
  },
  checkbox: {
    width: 20,
    height: 20,
    borderWidth: 2,
    borderColor: '#CBD5E1',
    borderRadius: 4,
    justifyContent: 'center',
    alignItems: 'center',
  },
  checkboxChecked: {
    backgroundColor: '#2563EB',
    borderColor: '#2563EB',
  },
  checkmark: {
    color: '#FFFFFF',
    fontSize: 12,
    fontWeight: '700',
  },
  checkboxLabel: {
    fontSize: 14,
    color: '#475569',
    flex: 1,
  },
  radioOption: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 10,
    paddingVertical: 6,
  },
  radio: {
    width: 20,
    height: 20,
    borderWidth: 2,
    borderColor: '#CBD5E1',
    borderRadius: 10,
    justifyContent: 'center',
    alignItems: 'center',
  },
  radioSelected: {
    borderColor: '#2563EB',
  },
  radioDot: {
    width: 10,
    height: 10,
    borderRadius: 5,
    backgroundColor: '#2563EB',
  },
  radioLabel: {
    fontSize: 14,
    color: '#475569',
  },
  rangeContainer: {
    gap: 8,
  },
  rangeInputs: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
  },
  rangeInput: {
    width: '100%',
    height: 40,
    borderWidth: 1,
    borderColor: '#CBD5E1',
    borderRadius: 6,
    paddingHorizontal: 12,
    fontSize: 14,
    color: '#0F172A',
    backgroundColor: '#FFFFFF',
  },
  rangeSeparator: {
    fontSize: 14,
    color: '#94A3B8',
  },
  selectContainer: {
    maxHeight: 200,
  },
  selectOption: {
    paddingVertical: 10,
    paddingHorizontal: 12,
    borderRadius: 6,
    marginBottom: 4,
  },
  selectOptionSelected: {
    backgroundColor: '#EFF6FF',
  },
  selectOptionText: {
    fontSize: 14,
    color: '#475569',
  },
  selectOptionTextSelected: {
    color: '#2563EB',
    fontWeight: '600',
  },
  categoryItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 10,
    paddingHorizontal: 12,
    borderRadius: 8,
    marginBottom: 4,
    backgroundColor: 'transparent',
  },
  categoryItemActive: {
    backgroundColor: '#DBEAFE',
    borderWidth: 2,
    borderColor: '#2563EB',
  },
  categoryText: {
    fontSize: 14,
    color: '#475569',
  },
  categoryTextActive: {
    color: '#2563EB',
    fontWeight: '700',
  },
  categoryCount: {
    fontSize: 13,
    color: '#94A3B8',
  },
  categoryCountActive: {
    color: '#2563EB',
    fontWeight: '600',
  },
  wilayasList: {
    maxHeight: 300,
  },
  wilayaItem: {
    paddingVertical: 8,
    paddingHorizontal: 10,
    borderRadius: 6,
    marginBottom: 2,
  },
  wilayaItemSelected: {
    backgroundColor: '#EFF6FF',
  },
  wilayaText: {
    fontSize: 14,
    color: '#475569',
  },
  wilayaTextSelected: {
    color: '#2563EB',
    fontWeight: '600',
  },
  textRTL: {
    textAlign: 'right',
    writingDirection: 'rtl',
  },
  emptyText: {
    fontSize: 14,
    color: '#94A3B8',
    textAlign: 'center',
    padding: 20,
  },
});
